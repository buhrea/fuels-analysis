---
title: "1c--My-Fires-Data-Exploration"
author: "Elizabeth Buhr"
date: "`r Sys.Date()`"
output: word_document
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(root.dir = 'C:/Users/Elizabeth Buhr/Documents/fuels-analysis/')
```

```{r}
#load packages
library(sf) 
library(terra)
library(tidyverse)
library(ggplot2)
```

```{r, include = FALSE}
gpkg_path <- "geopackages/fuels_analysis_v2.gpkg"

fire_id_column <- "Incid_Name"             

intersection <- st_read(gpkg_path, layer = "intersection")
fires <- st_read(gpkg_path, layer = "fires")
```

# Extent of Treatments in Individual Fires

```{r, fig.width=8, fig.height= 5}
# Group by fire ID and dissolve (union) geometries
gdf_treated_area <- intersection %>%
  group_by(!!sym(fire_id_column)) %>%
  summarise(
    geometry = st_union(geom),
    .groups = 'drop'
  )

# Calculate the unique treated area (in hectares)
gdf_treated_area <- gdf_treated_area %>%
  mutate(
    unique_treated_area_ha = as.numeric(st_area(geometry)) / 10000
  ) %>%
  st_drop_geometry() # Drop geometry to prepare for the join


# Calculate the total fire area (in hectares)
gdf_fires_area <- fires %>%
  mutate(
    total_fire_area_ha = as.numeric(st_area(geom)) / 10000
  ) %>%
  st_drop_geometry() %>% # Drop geometry
  select(!!sym(fire_id_column), total_fire_area_ha)



# Join the two datasets by the fire ID
analysis_data <- gdf_fires_area %>%
  left_join(gdf_treated_area, by = fire_id_column)

# Handle fires with NO treatment (their unique_treated_area_ha will be NA after the left_join)
analysis_data <- analysis_data %>%
  mutate(
    unique_treated_area_ha = replace_na(unique_treated_area_ha, 0)
  )

# Calculate the proportion
analysis_data <- analysis_data %>%
  mutate(
    proportion_treated = unique_treated_area_ha / total_fire_area_ha
  ) %>%
  # Filter out any fires with 0 area (just in case)
  filter(total_fire_area_ha > 0)

# Create the histogram using ggplot2
ggplot(data = analysis_data, aes(x = proportion_treated)) +
  geom_histogram(bins = 20) +
  labs(
    title = "Distribution of Proportion of Fire Area Treated (2015-2023)",
    x = "Proportion Treated (0 to 1)",
    y = "Number of Fires (Frequency)"
  ) +
  scale_x_continuous(labels = scales::percent, limits = c(0, 1.05)) + # Format X-axis as a percentage
  theme_bw()
```

# Size of Treatments

Summary statistics in hectares:

```{r}
# Size of Treatments by MGT_TYPE

# 1. Calculate the area of each individual treatment polygon
treatment_area_data_by_type <- intersection %>%
  # Calculate area in hectares for each feature in the intersection
  mutate(
    treatment_size_ha = as.numeric(st_area(geom)) / 10000 
  ) %>%
  st_drop_geometry() %>% # Drop geometry for plotting efficiency
  # Select only the required columns for plotting and comparison
  select(MGT_TYPE, treatment_size_ha)

#Summary statistics
SizeSumStats <- treatment_area_data_by_type %>%
  group_by(MGT_TYPE) %>%
  summarise(n = n(),
            min = min(treatment_size_ha),
            max = max(treatment_size_ha),
            mean = mean(treatment_size_ha),
            sd = sd(treatment_size_ha))

SizeSumStats
```

# Elevation
```{r}
# --- File Paths ---
gpkg_path <- "geopackages/fuels_analysis_v2.gpkg"
raster_path <- "data/LF2020_Elev_220_CONUS/Tif/LC20_Elev_220.tif"

# 1. Load Data
# Load the 'fires' and 'intersection' layers
fires_sf <- st_read(gpkg_path, layer = "fires")
intersection_sf <- st_read(gpkg_path, layer = "intersection")

# Load the elevation raster
elevation_rast <- rast(raster_path)

# Corrected get_elevation_range function
get_elevation_range <- function(geometry, raster) {
  
  # CRITICAL STEP: Convert the sf geometry object to a SpatVector
  # The 'terra::vect()' function handles the conversion from sf/sfc objects.
  spat_vector <- terra::vect(geometry) 
  
  # Use terra's extract function with the SpatVector
  # By setting fun = NULL, we get all values, then calculate min/max manually.
  values <- terra::extract(raster, spat_vector, fun = NULL, na.rm = TRUE)
  
  # Check if any non-NA values were extracted
  if (is.null(values) || all(is.na(values[, 2]))) {
    return(c(min_elev = NA, max_elev = NA))
  }
  
  # The second column contains the elevation values (column 1 is the ID)
  elev_values <- values[, 2] 
  
  # Calculate range
  min_val <- min(elev_values, na.rm = TRUE)
  max_val <- max(elev_values, na.rm = TRUE)
  
  return(c(min_elev = min_val, max_elev = max_val))
}

# 3. Main Processing Loop
fire_names <- unique(fires_sf$Incid_Name)
results_list <- list()

for (name in fire_names) {
  
  # --- Filter Data for the Current Fire ---
  
  # Get the total area geometry for the current fire (Union geometries if multiple parts exist)
  fire_geom <- fires_sf %>%
    filter(Incid_Name == name) %>%
    st_union()
  
  # Get the treated area geometry for the current fire
  treatment_geom <- intersection_sf %>%
    filter(Incid_Name == name) %>%
    st_union()
  
  # --- Calculate Elevation Ranges ---
  
  # a) Fire Range
  fire_range <- get_elevation_range(fire_geom, elevation_rast)
  
  # b) Treatment Range
  treatment_range <- get_elevation_range(treatment_geom, elevation_rast)
  
  # --- Compile Results ---
  results_list[[name]] <- data.frame(
    Incid_Name = name,
    Fire_Min_Elev = fire_range["min_elev"],
    Fire_Max_Elev = fire_range["max_elev"],
    Treatment_Min_Elev = treatment_range["min_elev"],
    Treatment_Max_Elev = treatment_range["max_elev"]
  )
}

# 4. Create Final Table
final_table <- do.call(rbind, results_list) %>%
  tibble::rownames_to_column(var = "ID") %>% # Clean up row names
  select(-ID)

# Display the resulting table
print(final_table)
```

# Create the Final Table

```{r}
fires_table <- left_join(final_table, analysis_data)
```

